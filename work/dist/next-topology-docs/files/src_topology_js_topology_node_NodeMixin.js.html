<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/topology/js/topology/node/NodeMixin.js - Next graph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Next graph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/nx.data.Convex.html">nx.data.Convex</a></li>
                                <li><a href="../classes/nx.data.Edge.html">nx.data.Edge</a></li>
                                <li><a href="../classes/nx.data.EdgeSet.html">nx.data.EdgeSet</a></li>
                                <li><a href="../classes/nx.data.EdgeSetCollection.html">nx.data.EdgeSetCollection</a></li>
                                <li><a href="../classes/nx.data.Force.html">nx.data.Force</a></li>
                                <li><a href="../classes/nx.data.ObservableGraph.html">nx.data.ObservableGraph</a></li>
                                <li><a href="../classes/nx.data.ObservableGraph.ForceProcessor.html">nx.data.ObservableGraph.ForceProcessor</a></li>
                                <li><a href="../classes/nx.data.Vertex.html">nx.data.Vertex</a></li>
                                <li><a href="../classes/nx.data.VertexSet.html">nx.data.VertexSet</a></li>
                                <li><a href="../classes/nx.geometry.BezierCurve.html">nx.geometry.BezierCurve</a></li>
                                <li><a href="../classes/nx.geometry.Line.html">nx.geometry.Line</a></li>
                                <li><a href="../classes/nx.geometry.Math.html">nx.geometry.Math</a></li>
                                <li><a href="../classes/nx.geometry.Matrix.html">nx.geometry.Matrix</a></li>
                                <li><a href="../classes/nx.geometry.nx.graphic.Arc.html">nx.geometry.nx.graphic.Arc</a></li>
                                <li><a href="../classes/nx.geometry.Vector.html">nx.geometry.Vector</a></li>
                                <li><a href="../classes/nx.graphic.BezierCurves.html">nx.graphic.BezierCurves</a></li>
                                <li><a href="../classes/nx.graphic.Circle.html">nx.graphic.Circle</a></li>
                                <li><a href="../classes/nx.graphic.Component.html">nx.graphic.Component</a></li>
                                <li><a href="../classes/nx.graphic.DragManager.html">nx.graphic.DragManager</a></li>
                                <li><a href="../classes/nx.graphic.Group.html">nx.graphic.Group</a></li>
                                <li><a href="../classes/nx.graphic.Icon.html">nx.graphic.Icon</a></li>
                                <li><a href="../classes/nx.graphic.Icons.html">nx.graphic.Icons</a></li>
                                <li><a href="../classes/nx.graphic.Image.html">nx.graphic.Image</a></li>
                                <li><a href="../classes/nx.graphic.Line.html">nx.graphic.Line</a></li>
                                <li><a href="../classes/nx.graphic.LinkSetTooltipContent.html">nx.graphic.LinkSetTooltipContent</a></li>
                                <li><a href="../classes/nx.graphic.LinkTooltipContent.html">nx.graphic.LinkTooltipContent</a></li>
                                <li><a href="../classes/nx.graphic.NodeTooltipContent.html">nx.graphic.NodeTooltipContent</a></li>
                                <li><a href="../classes/nx.graphic.Path.html">nx.graphic.Path</a></li>
                                <li><a href="../classes/nx.graphic.Polygon.html">nx.graphic.Polygon</a></li>
                                <li><a href="../classes/nx.graphic.Rect.html">nx.graphic.Rect</a></li>
                                <li><a href="../classes/nx.graphic.Stage.html">nx.graphic.Stage</a></li>
                                <li><a href="../classes/nx.graphic.Text.html">nx.graphic.Text</a></li>
                                <li><a href="../classes/nx.graphic.Topology.html">nx.graphic.Topology</a></li>
                                <li><a href="../classes/nx.graphic.Topology.AbstractLink.html">nx.graphic.Topology.AbstractLink</a></li>
                                <li><a href="../classes/nx.graphic.Topology.AbstractNode.html">nx.graphic.Topology.AbstractNode</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Categories.html">nx.graphic.Topology.Categories</a></li>
                                <li><a href="../classes/nx.graphic.Topology.CircleGroup.html">nx.graphic.Topology.CircleGroup</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Config.html">nx.graphic.Topology.Config</a></li>
                                <li><a href="../classes/nx.graphic.Topology.DefaultScene.html">nx.graphic.Topology.DefaultScene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Event.html">nx.graphic.Topology.Event</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Graph.html">nx.graphic.Topology.Graph</a></li>
                                <li><a href="../classes/nx.graphic.Topology.GroupItem.html">nx.graphic.Topology.GroupItem</a></li>
                                <li><a href="../classes/nx.graphic.Topology.GroupsLayer.html">nx.graphic.Topology.GroupsLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Layer.html">nx.graphic.Topology.Layer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LayoutMixin.html">nx.graphic.Topology.LayoutMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Link.html">nx.graphic.Topology.Link</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LinkMixin.html">nx.graphic.Topology.LinkMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LinkSet.html">nx.graphic.Topology.LinkSet</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LinksLayer.html">nx.graphic.Topology.LinksLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NeXtForceLayout.html">nx.graphic.Topology.NeXtForceLayout</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Node.html">nx.graphic.Topology.Node</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NodeMixin.html">nx.graphic.Topology.NodeMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NodeSet.html">nx.graphic.Topology.NodeSet</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NodesLayer.html">nx.graphic.Topology.NodesLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Path.html">nx.graphic.Topology.Path</a></li>
                                <li><a href="../classes/nx.graphic.Topology.PathLayer.html">nx.graphic.Topology.PathLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.PolygonGroup.html">nx.graphic.Topology.PolygonGroup</a></li>
                                <li><a href="../classes/nx.graphic.Topology.RectGroup.html">nx.graphic.Topology.RectGroup</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Scene.html">nx.graphic.Topology.Scene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.SceneMixin.html">nx.graphic.Topology.SceneMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.SelectionNodeScene.html">nx.graphic.Topology.SelectionNodeScene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.SelectionScene.html">nx.graphic.Topology.SelectionScene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.StageMixin.html">nx.graphic.Topology.StageMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.ThreeDLayer.html">nx.graphic.Topology.ThreeDLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Thumbnail.html">nx.graphic.Topology.Thumbnail</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Tooltip.html">nx.graphic.Topology.Tooltip</a></li>
                                <li><a href="../classes/nx.graphic.Topology.TooltipManager.html">nx.graphic.Topology.TooltipManager</a></li>
                                <li><a href="../classes/nx.graphic.Topology.TooltipMixin.html">nx.graphic.Topology.TooltipMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.TooltipPolicy.html">nx.graphic.Topology.TooltipPolicy</a></li>
                                <li><a href="../classes/nx.graphic.Topology.USMapLayout.html">nx.graphic.Topology.USMapLayout</a></li>
                                <li><a href="../classes/nx.graphic.Topology.WorldMapLayout.html">nx.graphic.Topology.WorldMapLayout</a></li>
                                <li><a href="../classes/nx.graphic.Topology.ZoomBySelection.html">nx.graphic.Topology.ZoomBySelection</a></li>
                                <li><a href="../classes/nx.graphic.Triangle.html">nx.graphic.Triangle</a></li>
                                <li><a href="../classes/nx.ui.Popover.html">nx.ui.Popover</a></li>
                                <li><a href="../classes/nx.ui.Popup.html">nx.ui.Popup</a></li>
                                <li><a href="../classes/nx.ui.PopupContainer.html">nx.ui.PopupContainer</a></li>
                                <li><a href="../classes/nx.widget.ZIndexManager.html">nx.widget.ZIndexManager</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/nx.data.html">nx.data</a></li>
                                <li><a href="../modules/nx.geometry.html">nx.geometry</a></li>
                                <li><a href="../modules/nx.graphic.html">nx.graphic</a></li>
                                <li><a href="../modules/nx.graphic.Topology.html">nx.graphic.Topology</a></li>
                                <li><a href="../modules/nx.graphic.Topology.Group.html">nx.graphic.Topology.Group</a></li>
                                <li><a href="../modules/nx.math.html">nx.math</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/topology/js/topology/node/NodeMixin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function (nx, global) {

    var util = nx.util;


    /**
     * Node mixin class
     * @class nx.graphic.Topology.NodeMixin
     * @module nx.graphic.Topology
     */
    nx.define(&quot;nx.graphic.Topology.NodeMixin&quot;, {
        events: [&#x27;addNode&#x27;, &#x27;deleteNode&#x27;, &#x27;addNodeSet&#x27;, &#x27;deleteNodeSet&#x27;, &#x27;expandAll&#x27;],
        properties: {
            /**
             * Node instance class name, support function
            * @property nodeInstanceClass
             */
            nodeInstanceClass: {
                value: &#x27;nx.graphic.Topology.Node&#x27;
            },
            /**
             * NodeSet instance class name, support function
             * @property nodeSetInstanceClass
             */
            nodeSetInstanceClass: {
                value: &#x27;nx.graphic.Topology.NodeSet&#x27;
            },
            /**
             * Set node&#x27;s draggable
             * @property nodeDraggable
             */
            nodeDraggable: {
                value: true
            },
            /**
             * Enable smart label
             * @property enableSmartLabel
             */
            enableSmartLabel: {
                value: true
            },
            /**
             * Show or hide node&#x27;s icon
             * @property showIcon
             */
            showIcon: {
                get: function () {
                    return this._showIcon !== undefined ? this._showIcon : false;
                },
                set: function (value) {
                    if (this._showIcon !== value) {
                        this._showIcon = value;
                        if (this.status() !== &quot;initializing&quot;) {
                            this.eachNode(function (node) {
                                node.showIcon(value);
                            });
                        }
                        return true;
                    } else {
                        return false;
                    }
                }
            },
            /**
             * All node&#x27;s config. key is node&#x27;s property, support super binding
             * value could be a single string eg: color:&#x27;#f00&#x27;
             * value could be a an expression eg: label :&#x27;{model.id}&#x27;
             * value could be a function eg iconType : function (model,instance){ return  &#x27;router&#x27;}
             * value could be a normal binding expression eg : label :&#x27;{#label}&#x27;
             * @property {nodeConfig}
             */
            nodeConfig: {},
            /**
             * All nodeSet&#x27;s config. key is node&#x27;s property, support super binding
             * value could be a single string eg: color:&#x27;#f00&#x27;
             * value could be a an expression eg: label :&#x27;{model.id}&#x27;
             * value could be a function eg iconType : function (model,instance){ return  &#x27;router&#x27;}
             * value could be a normal binding expression eg : label :&#x27;{#label}&#x27;
             * @property {nodeSetConfig}
             */
            nodeSetConfig: {},
            /**
             * All selected nodes, could direct add/remove nodes to this collection
             * @property selectedNodes {nx.data.ObservableCollection}
             */
            selectedNodes: {
                value: function () {
                    return new nx.data.UniqObservableCollection();
                }
            },
            activeNodes: {
                set: function (value) {
                    var nodesLayer = this.getLayer(&quot;nodes&quot;);
                    var nodeSetLayer = this.getLayer(&quot;nodeSet&quot;);
                    var watcher = this._activeNodesWatcher;
                    if (!watcher) {
                        watcher = this._activeNodesWatcher = new nx.graphic.Topology.NodeWatcher();
                        watcher.topology(this);
                        watcher.updater(function () {
                            var nodes = watcher.getNodes();
                            nx.each(nodes, function (node) {
                                if (node.model().type() == &#x27;vertex&#x27;) {
                                    nodesLayer.activeElements().add(node);
                                } else {
                                    nodeSetLayer.activeElements().add(node);
                                }
                            }, this);
                        }.bind(this));


                    }
                    nodesLayer.activeElements().clear();
                    nodeSetLayer.activeElements().clear();
                    watcher.nodes(value);
                    this._activeNodes = value;
                }
            },
            highlightedNodes: {
                set: function (value) {
                    var nodesLayer = this.getLayer(&quot;nodes&quot;);
                    var nodeSetLayer = this.getLayer(&quot;nodeSet&quot;);
                    var watcher = this._highlightedNodesWatcher;
                    if (!watcher) {
                        watcher = this._highlightedNodesWatcher = new nx.graphic.Topology.NodeWatcher();
                        watcher.topology(this);
                        watcher.updater(function () {
                            nx.each(watcher.getNodes(), function (node) {
                                if (node.model().type() == &#x27;vertex&#x27;) {
                                    nodesLayer.highlightedElements().add(node);
                                } else {
                                    nodeSetLayer.highlightedElements().add(node);
                                }
                            }, this);
                        }.bind(this));
                    }

                    nodesLayer.highlightedElements().clear();
                    nodeSetLayer.highlightedElements().clear();
                    watcher.nodes(value);
                    this._highlightedNodes = value;
                }
            },
            enableNodeSetAnimation: {
                value: true
            },
            aggregationRule: {}
        },
        methods: {
            initNode: function () {
                var selectedNodes = this.selectedNodes();
                selectedNodes.on(&#x27;change&#x27;, function (sender, args) {
                    if (args.action == &#x27;add&#x27;) {
                        nx.each(args.items, function (node) {
                            node.selected(true);
                            node.on(&#x27;remove&#x27;, this._removeSelectedNode = function () {
                                selectedNodes.remove(node);
                            }, this);
                        }, this);
                    } else if (args.action == &#x27;remove&#x27;) {
                        nx.each(args.items, function (node) {
                            node.selected(false);
                            node.off(&#x27;remove&#x27;, this._removeSelectedNode, this);
                        }, this);
                    } else if (args.action == &quot;clear&quot;) {
                        nx.each(args.items, function (node) {
                            node.selected(false);
                            node.off(&#x27;remove&#x27;, this._removeSelectedNode, this);
                        }, this);
                    }
                });
            },
            /**
             * Add a node to topology
             * @method addNode
             * @param obj
             * @param inOption
             * @returns {*}
             */
            addNode: function (obj, inOption) {
                var vertex = this.graph().addVertex(obj, inOption);
                if (vertex) {
                    var node = this.getNode(vertex.id());
                    this.fire(&quot;addNode&quot;, node);
                    return node;
                } else {
                    return null;
                }

            },

            /**
             * Remove a node
             * @method removeNode
             * @param arg
             * @returns {boolean}
             */
            removeNode: function (arg, callback, context) {
                this.deleteNode(arg);
            },
            deleteNode: function (arg, callback, context) {
                var id = arg;
                if (nx.is(arg, nx.graphic.Topology.AbstractNode)) {
                    id = arg.id();
                }
                var vertex = this.graph().getVertex(id);
                if (vertex) {
                    var node = this.getNode(id);
                    this.fire(&quot;deleteNode&quot;, node);
                    this.graph().deleteVertex(id);
                    if (callback) {
                        callback.call(context || this);
                    }
                }
            },
            _getAggregationTargets: function (vertices) {
                var graph = this.graph();
                var mark, marks, markmap = {}, NONE = nx.util.uuid();
                var i, v, vp, vpid, changed, vs = vertices.slice();
                // iterate unless the aggregation successful
                do {
                    changed = false;
                    for (i = vs.length - 1; i &gt;= 0; i--) {
                        v = vs[i];
                        // get the parent vertex and its ID
                        vp = v.parentVertexSet();
                        vpid = (vp ? vp.id() : NONE);
                        // check if same parent vertex marked
                        if (!markmap.hasOwnProperty(vpid)) {
                            // create mark for the parent vertex
                            markmap[vpid] = {
                                vertex: vp || graph,
                                finding: graph.subordinates(vp),
                                found: []
                            };
                        }
                        // get parent mark
                        mark = markmap[vpid];
                        // check if child vertex marked already
                        if (mark === false || mark.found.indexOf(v) &gt;= 0) {
                            // duplicated vertex appears, unable to aggregate
                            throw &quot;wrong input&quot;;
                        }
                        // mark child vertex to its parent vertex
                        mark.found.push(v);
                        // remove child vertex from the pool
                        vs.splice(i, 1);
                        // set the vertex array changed
                        changed = true;
                        // check if the parent vertex is fully matched
                        if (mark.finding.length === mark.found.length &amp;&amp; mark.vertex !== graph) {
                            // add parent vertex from the pool
                            vs.push(mark.vertex);
                            // mark the parent vertex as fully matched
                            markmap[vpid] = false;
                        }
                    }
                } while (changed);
                // clear fully matched marks from mark map
                for (mark in markmap) {
                    if (!markmap[mark]) {
                        delete markmap[mark];
                    }
                }
                // get remain marks of parent vertices
                marks = nx.util.values(markmap);
                // check if the number of parent not fully matched
                if (marks.length !== 1) {
                    // it should be at most &amp; least one
                    throw nx.graphic.Topology.i18n.cantAggregateNodesInDifferentNodeSet;
                }
                // get the only parent&#x27;s mark
                mark = marks[0];
                return mark.found;
            },
            aggregationNodes: function (inNodes, inConfig) {
                // transform nodes or node ids into vertices
                var nodes = [],
                    vertices = [];
                nx.each(inNodes, function (node) {
                    if (!nx.is(node, nx.graphic.Topology.AbstractNode)) {
                        node = this.getNode(node);
                    }
                    if (!nx.is(node, nx.graphic.Topology.AbstractNode)) {
                        throw &quot;wrong input&quot;;
                    }
                    nodes.push(node);
                    vertices.push(node.model());
                }.bind(this));
                // get aggregate target vertices and ids
                var aggregateVertices, aggregateIds;
                // FIXME catch or not
                aggregateVertices = this._getAggregationTargets(vertices);
                if (aggregateVertices.length &lt; 2) {
                    throw &quot;wrong input. unable to aggregate.&quot;;
                }
                aggregateIds = [];
                nx.each(aggregateVertices, function (vertex) {
                    aggregateIds.push(vertex.id());
                });
                // check the user rule
                var aggregationRule = this.aggregationRule();
                if (aggregationRule &amp;&amp; nx.is(aggregationRule, &#x27;Function&#x27;)) {
                    var result = aggregationRule.call(this, nodes, inConfig);
                    if (result === false) {
                        return;
                    }
                }
                // make up data, config and parent
                var data, parent, pn = null,
                    config = {};
                data = {
                    nodes: aggregateIds,
                    x: (inConfig &amp;&amp; typeof inConfig.x === &quot;number&quot; ? inConfig.x : aggregateVertices[0].x()),
                    y: (inConfig &amp;&amp; typeof inConfig.y === &quot;number&quot; ? inConfig.y : aggregateVertices[0].y()),
                    label: (inConfig &amp;&amp; inConfig.label || [nodes[0].label(), nodes[nodes.length - 1].label()].sort().join(&quot;-&quot;))
                };
                parent = aggregateVertices[0].parentVertexSet();
                if (parent) {
                    config.parentVertexSetID = parent.id();
                    pn = this.getNode(parent.id());
                }
                var nodeSet = this.addNodeSet(data, config, pn);
                this.stage().resetFitMatrix();
                return nodeSet;
            },
            /**
             * Add a nodeSet
             * @method addNodeSet
             * @param obj
             * @param [inOption]
             * @param [parentNodeSet]
             * @returns {*}
             */
            addNodeSet: function (obj, inOption, parentNodeSet) {
                var vertex = this.graph().addVertexSet(obj, inOption);
                if (vertex) {
                    var nodeSet = this.getNode(vertex.id());
                    if (parentNodeSet) {
                        nodeSet.parentNodeSet(parentNodeSet);
                    }
                    this.fire(&quot;addNodeSet&quot;, nodeSet);
                    return nodeSet;
                } else {
                    return null;
                }

            },
            removeNodeSet: function (arg, callback, context) {
                this.deleteNodeSet(arg);
            },

            deleteNodeSet: function (arg, callback, context) {
                if (!arg) {
                    return;
                }
                var id = arg;
                if (nx.is(arg, nx.graphic.Topology.AbstractNode)) {
                    id = arg.id();
                }
                var nodeSet = this.getLayer(&quot;nodeSet&quot;).getNodeSet(id);
                if (nodeSet) {
                    if (nodeSet.collapsed()) {
                        nodeSet.activated(false);
                        nodeSet.expandNodes(function () {
                            this.fire(&quot;deleteNodeSet&quot;, nodeSet);
                            this.graph().deleteVertexSet(id);
                            if (callback) {
                                callback.call(context || this);
                            }
                        }, this);
                    } else {
                        this.fire(&quot;deleteNodeSet&quot;, nodeSet);
                        this.graph().deleteVertexSet(id);
                        if (callback) {
                            callback.call(context || this);
                        }
                    }

                } else {
                    this.graph().deleteVertexSet(id);
                    if (callback) {
                        callback.call(context || this);
                    }
                }
            },


            /**
             * Traverse each node
             * @method eachNode
             * @param callback
             * @param context
             */
            eachNode: function (callback, context) {
                this.getLayer(&quot;nodes&quot;).eachNode(callback, context || this);
                this.getLayer(&quot;nodeSet&quot;).eachNodeSet(callback, context || this);
            },
            /**
             * Get node by node id
             * @method getNode
             * @param id
             * @returns {*}
             */
            getNode: function (id) {
                return this.getLayer(&quot;nodes&quot;).getNode(id) || this.getLayer(&quot;nodeSet&quot;).getNodeSet(id);
            },
            /**
             * Get all visible nodes
             * @returns {Array}
             */
            getNodes: function () {
                var nodes = this.getLayer(&quot;nodes&quot;).nodes();
                var nodeSets = this.getLayer(&quot;nodeSet&quot;).nodeSets();
                if (nodeSets &amp;&amp; nodeSets.length !== 0) {
                    return nodes.concat(nodeSets);
                } else {
                    return nodes;
                }
            },
            /**
             * Register a customize icon
             * @param name {String}
             * @param url {URL}
             * @param width {Number}
             * @param height {Number}
             */
            registerIcon: function (name, url, width, height) {
                var XLINK = &#x27;http://www.w3.org/1999/xlink&#x27;;
                var NS = &quot;http://www.w3.org/2000/svg&quot;;
                var icon1 = document.createElementNS(NS, &quot;image&quot;);
                icon1.setAttributeNS(XLINK, &#x27;href&#x27;, url);
                nx.graphic.Icons.icons[name] = {
                    size: {
                        width: width,
                        height: height
                    },
                    icon: icon1.cloneNode(true),
                    name: name
                };

                var icon = icon1.cloneNode(true);
                icon.setAttribute(&quot;height&quot;, height);
                icon.setAttribute(&quot;width&quot;, width);
                icon.setAttribute(&quot;data-device-type&quot;, name);
                icon.setAttribute(&quot;id&quot;, name);
                icon.setAttribute(&quot;class&quot;, &#x27;deviceIcon&#x27;);
                this.stage().addDef(icon);
            },
            /**
             * Batch action, highlight node and related nodes and connected links.
             * @param inNode
             */
            highlightRelatedNode: function (inNode) {
                var node;
                if (inNode == null) {
                    return;
                }

                if (nx.is(inNode, nx.graphic.Topology.AbstractNode)) {
                    node = inNode;
                } else {
                    node = this.getNode(inNode);
                }
                if (!node) {
                    return;
                }


                var nodeSetLayer = this.getLayer(&#x27;nodeSet&#x27;);
                var nodeLayer = this.getLayer(&#x27;nodes&#x27;);

                //highlight node
                if (nx.is(node, &#x27;nx.graphic.Topology.NodeSet&#x27;)) {
                    nodeSetLayer.highlightedElements().add(node);
                } else {
                    nodeLayer.highlightedElements().add(node);
                }


                // highlight connected nodes and nodeSets
                node.eachConnectedNode(function (n) {
                    if (nx.is(n, &#x27;nx.graphic.Topology.NodeSet&#x27;)) {
                        nodeSetLayer.highlightedElements().add(n);
                    } else {
                        nodeLayer.highlightedElements().add(n);
                    }
                }, this);


                // highlight connected links and linkSets
                this.getLayer(&#x27;linkSet&#x27;).highlightLinkSets(util.values(node.linkSets()));
                this.getLayer(&#x27;links&#x27;).highlightLinks(util.values(node.links()));

                this.fadeOut(true);

            },
            /**
             * Batch action, highlight node and related nodes and connected links.
             * @param inNode
             */
            activeRelatedNode: function (inNode) {

                var node;
                if (!inNode) {
                    return;
                }

                if (nx.is(inNode, nx.graphic.Topology.AbstractNode)) {
                    node = inNode;
                } else {
                    node = this.getNode(inNode);
                }
                if (!node) {
                    return;
                }


                var nodeSetLayer = this.getLayer(&#x27;nodeSet&#x27;);
                var nodeLayer = this.getLayer(&#x27;nodes&#x27;);

                // active node
                if (nx.is(node, &#x27;nx.graphic.Topology.NodeSet&#x27;)) {
                    nodeSetLayer.activeElements().add(node);
                } else {
                    nodeLayer.activeElements().add(node);
                }


                // highlight connected nodes and nodeSets
                node.eachConnectedNode(function (n) {
                    if (nx.is(n, &#x27;nx.graphic.Topology.NodeSet&#x27;)) {
                        nodeSetLayer.activeElements().add(n);
                    } else {
                        nodeLayer.activeElements().add(n);
                    }
                }, this);


                // highlight connected links and linkSets
                this.getLayer(&#x27;linkSet&#x27;).activeLinkSets(util.values(node.linkSets()));
                this.getLayer(&#x27;links&#x27;).activeLinks(util.values(node.links()));

                this.fadeOut();

            },
            /**
             * Zoom topology to let the passing nodes just visible at the screen
             * @method zoomByNodes
             * @param [callback] {Function} callback function
             * @param [context] {Object} callback context
             * @param nodes {Array} nodes collection
             */
            zoomByNodes: function (nodes, callback, context, boundScale) {
                // TODO more overload about nodes
                if (!nx.is(nodes, Array)) {
                    nodes = [nodes];
                }
                // get bound of the selected nodes&#x27; models
                var stage = this.stage();
                var p0, p1, center, bound = this.getModelBoundByNodes(nodes);
                var delta, limitscale = stage.maxZoomLevel() * stage.fitMatrixObject().scale();

                if (!bound) {
                    return;
                }

                // check if the nodes are too close to zoom
                if (bound.width * limitscale &lt; 1 &amp;&amp; bound.height * limitscale &lt; 1) {
                    // just centralize them instead of zoom
                    center = nx.geometry.Vector.transform(bound.center, stage.matrix());
                    delta = [stage.width() / 2 - center[0], stage.height() / 2 - center[1]];
                    stage.scalingLayer().setTransition(function () {
                        this.adjustLayout();
                        /* jshint -W030 */
                        callback &amp;&amp; callback.call(context || this);
                        this.fire(&#x27;zoomend&#x27;);
                    }, this, 0.6);
                    stage.applyTranslate(delta[0], delta[1]);
                    stage.applyStageScale(stage.maxZoomLevel() / stage.zoomLevel() * boundScale);
                } else {
                    p0 = nx.geometry.Vector.transform([bound.left, bound.top], stage.matrix());
                    p1 = nx.geometry.Vector.transform([bound.right, bound.bottom], stage.matrix());
                    bound = {
                        left: p0[0],
                        top: p0[1],
                        width: Math.max(1, p1[0] - p0[0]),
                        height: Math.max(1, p1[1] - p0[1])
                    };

                    boundScale = 1 / (boundScale || 1);
                    bound.left += bound.width * (1 - boundScale) / 2;
                    bound.top += bound.height * (1 - boundScale) / 2;
                    bound.height *= boundScale;
                    bound.width *= boundScale;

                    this.zoomByBound(bound, function () {
                        this.adjustLayout();
                        /* jshint -W030 */
                        callback &amp;&amp; callback.call(context || this);
                        this.fire(&#x27;zoomend&#x27;);
                    }, this);
                }
            },
            getModelBoundByNodes: function (nodes, isIncludeInvisibleNodes) {
                var xmin, xmax, ymin, ymax;
                nx.each(nodes, function (inNode) {
                    var vertex;
                    if (nx.is(inNode, nx.graphic.Topology.AbstractNode)) {
                        vertex = inNode.model();
                    } else {
                        if (isIncludeInvisibleNodes) {
                            vertex = this.graph().getVertex(inNode) || this.graph().getVertexSet(inNode);
                        } else {
                            var node = this.getNode(inNode);
                            vertex = node &amp;&amp; node.model();
                        }
                    }
                    if (!vertex) {
                        return;
                    }


                    var x = vertex.x(),
                        y = vertex.y();
                    xmin = (xmin &lt; x ? xmin : x);
                    ymin = (ymin &lt; y ? ymin : y);
                    xmax = (xmax &gt; x ? xmax : x);
                    ymax = (ymax &gt; y ? ymax : y);
                }, this);
                if (xmin === undefined || ymin === undefined) {
                    return undefined;
                }
                return {
                    left: xmin,
                    top: ymin,
                    right: xmax,
                    bottom: ymax,
                    center: [(xmax + xmin) / 2, (ymax + ymin) / 2],
                    width: xmax - xmin,
                    height: ymax - ymin
                };
            },
            /**
             * Get the bound of passing node&#x27;s
             * @param inNodes {Array}
             * @param isNotIncludeLabel {Boolean}
             * @returns {Array}
             */

            getBoundByNodes: function (inNodes, isNotIncludeLabel) {

                if (inNodes == null || inNodes.length === 0) {
                    inNodes = this.getNodes();
                }

                var bound = {
                    left: 0,
                    top: 0,
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    maxX: 0,
                    maxY: 0
                };

                var boundAry = [];


                nx.each(inNodes, function (inNode) {
                    var node;
                    if (nx.is(inNode, nx.graphic.Topology.AbstractNode)) {
                        node = inNode;
                    } else {
                        node = this.getNode(inNode);
                    }

                    if (!node) {
                        return;
                    }


                    if (node.visible()) {
                        if (isNotIncludeLabel) {
                            boundAry.push(this.getInsideBound(node.getBound(true)));
                        } else {
                            boundAry.push(this.getInsideBound(node.getBound()));
                        }
                    }
                }, this);


                var lastIndex = boundAry.length - 1;

                //
                boundAry.sort(function (a, b) {
                    return a.left - b.left;
                });

                bound.x = bound.left = boundAry[0].left;
                bound.maxX = boundAry[lastIndex].left;

                boundAry.sort(function (a, b) {
                    return (a.left + a.width) - (b.left + b.width);
                });

                bound.width = boundAry[lastIndex].left + boundAry[lastIndex].width - bound.x;


                //
                boundAry.sort(function (a, b) {
                    return a.top - b.top;
                });

                bound.y = bound.top = boundAry[0].top;
                bound.maxY = boundAry[lastIndex].top;

                boundAry.sort(function (a, b) {
                    return (a.top + a.height) - (b.top + b.height);
                });

                bound.height = boundAry[lastIndex].top + boundAry[lastIndex].height - bound.y;

                return bound;


            },
            _moveSelectionNodes: function (event, node) {
                if (this.nodeDraggable()) {
                    var nodes = this.selectedNodes().toArray();
                    var stageScale = this.stageScale();
                    if (nodes.indexOf(node) === -1) {
                        node.move(event.drag.delta[0] * stageScale, event.drag.delta[1] * stageScale);
                    } else {
                        nx.each(nodes, function (node) {
                            node.move(event.drag.delta[0] * stageScale, event.drag.delta[1] * stageScale);
                        });
                    }
                }
            },
            expandNodes: function (nodes, sourcePosition, callback, context, isAnimate) {

                var nodesLength = nx.is(nodes, Array) ? nodes.length : nx.util.keys(nodes).length;
                callback = callback || function () {
                };


                if (nodesLength &gt; 150 || nodesLength === 0 || isAnimate === false) {
                    callback.call(context || this, this);
                } else {
                    var positionMap = [];
                    nx.each(nodes, function (node) {
                        positionMap.push({
                            id: node.id(),
                            position: node.position(),
                            node: node
                        });
                        node.position(sourcePosition);
                    }, this);

                    if (this._nodesAnimation) {
                        this._nodesAnimation.stop();
                    }

                    var ani = this._nodesAnimation = new nx.graphic.Animation({
                        duration: 600
                    });
                    ani.callback(function (progress) {
                        nx.each(positionMap, function (item) {
                            var _position = item.position;
                            var node = item.node;
                            if (node &amp;&amp; node.model()) {
                                node.position({
                                    x: sourcePosition.x + (_position.x - sourcePosition.x) * progress,
                                    y: sourcePosition.y + (_position.y - sourcePosition.y) * progress
                                });
                            }
                        });
                    }.bind(this));

                    ani.complete(function () {
                        callback.call(context || this, this);
                    }.bind(this));
                    ani.start();
                }
            },
            collapseNodes: function (nodes, targetPosition, callback, context, isAnimate) {
                var nodesLength = nx.is(nodes, Array) ? nodes.length : nx.util.keys(nodes).length;
                callback = callback || function () {
                };


                if (nodesLength &gt; 150 || nodesLength === 0 || isAnimate === false) {
                    callback.call(context || this, this);
                } else {
                    var positionMap = [];
                    nx.each(nodes, function (node) {
                        positionMap.push({
                            id: node.id(),
                            position: node.position(),
                            node: node,
                            vertex: node.model(),
                            vertexPosition: node.model().position()
                        });
                    }, this);

                    if (this._nodesAnimation) {
                        this._nodesAnimation.stop();
                    }


                    var ani = this._nodesAnimation = new nx.graphic.Animation({
                        duration: 600
                    });
                    ani.callback(function (progress) {
                        nx.each(positionMap, function (item) {
                            var _position = item.position;
                            var node = item.node;
                            if (node &amp;&amp; node.model()) {
                                node.position({
                                    x: _position.x - (_position.x - targetPosition.x) * progress,
                                    y: _position.y - (_position.y - targetPosition.y) * progress
                                });
                            }
                        });
                    }.bind(this));

                    ani.complete(function () {
                        nx.each(positionMap, function (item) {
                            item.vertex.position(item.vertexPosition);
                        });
                        callback.call(context || this, this);
                    }.bind(this));
                    ani.start();
                }
            },
            expandAll: function () {
                var nodeSetLayer = this.getLayer(&#x27;nodeSet&#x27;);
                //console.time(&#x27;expandAll&#x27;);
                var fn = function (callback) {
                    var isFinished = true;
                    nodeSetLayer.eachNodeSet(function (nodeSet) {
                        if (nodeSet.visible()) {
                            nodeSet.animation(false);
                            nodeSet.collapsed(false);
                            isFinished = false;
                        }
                    });
                    if (!isFinished) {
                        fn(callback);
                    } else {
                        callback();
                    }
                };

                this.showLoading();

                setTimeout(function () {
                    fn(function () {

                        nodeSetLayer.eachNodeSet(function (nodeSet) {
                            nodeSet.animation(true);
                        });
                        this.stage().resetFitMatrix();
                        this.hideLoading();
                        this.fit(function () {
                            this.blockEvent(false);
                            this.fire(&#x27;expandAll&#x27;);
                        }, this);
                    }.bind(this));
                }.bind(this), 100);

            }
        }
    });


})(nx, nx.global);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
