<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/topology/js/topology/path/Path.js - Next graph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Next graph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/nx.data.Convex.html">nx.data.Convex</a></li>
                                <li><a href="../classes/nx.data.Edge.html">nx.data.Edge</a></li>
                                <li><a href="../classes/nx.data.EdgeSet.html">nx.data.EdgeSet</a></li>
                                <li><a href="../classes/nx.data.EdgeSetCollection.html">nx.data.EdgeSetCollection</a></li>
                                <li><a href="../classes/nx.data.Force.html">nx.data.Force</a></li>
                                <li><a href="../classes/nx.data.ObservableGraph.html">nx.data.ObservableGraph</a></li>
                                <li><a href="../classes/nx.data.ObservableGraph.ForceProcessor.html">nx.data.ObservableGraph.ForceProcessor</a></li>
                                <li><a href="../classes/nx.data.Vertex.html">nx.data.Vertex</a></li>
                                <li><a href="../classes/nx.data.VertexSet.html">nx.data.VertexSet</a></li>
                                <li><a href="../classes/nx.geometry.BezierCurve.html">nx.geometry.BezierCurve</a></li>
                                <li><a href="../classes/nx.geometry.Line.html">nx.geometry.Line</a></li>
                                <li><a href="../classes/nx.geometry.Math.html">nx.geometry.Math</a></li>
                                <li><a href="../classes/nx.geometry.Matrix.html">nx.geometry.Matrix</a></li>
                                <li><a href="../classes/nx.geometry.nx.graphic.Arc.html">nx.geometry.nx.graphic.Arc</a></li>
                                <li><a href="../classes/nx.geometry.Vector.html">nx.geometry.Vector</a></li>
                                <li><a href="../classes/nx.graphic.BezierCurves.html">nx.graphic.BezierCurves</a></li>
                                <li><a href="../classes/nx.graphic.Circle.html">nx.graphic.Circle</a></li>
                                <li><a href="../classes/nx.graphic.Component.html">nx.graphic.Component</a></li>
                                <li><a href="../classes/nx.graphic.DragManager.html">nx.graphic.DragManager</a></li>
                                <li><a href="../classes/nx.graphic.Group.html">nx.graphic.Group</a></li>
                                <li><a href="../classes/nx.graphic.Icon.html">nx.graphic.Icon</a></li>
                                <li><a href="../classes/nx.graphic.Icons.html">nx.graphic.Icons</a></li>
                                <li><a href="../classes/nx.graphic.Image.html">nx.graphic.Image</a></li>
                                <li><a href="../classes/nx.graphic.Line.html">nx.graphic.Line</a></li>
                                <li><a href="../classes/nx.graphic.LinkSetTooltipContent.html">nx.graphic.LinkSetTooltipContent</a></li>
                                <li><a href="../classes/nx.graphic.LinkTooltipContent.html">nx.graphic.LinkTooltipContent</a></li>
                                <li><a href="../classes/nx.graphic.NodeTooltipContent.html">nx.graphic.NodeTooltipContent</a></li>
                                <li><a href="../classes/nx.graphic.Path.html">nx.graphic.Path</a></li>
                                <li><a href="../classes/nx.graphic.Polygon.html">nx.graphic.Polygon</a></li>
                                <li><a href="../classes/nx.graphic.Rect.html">nx.graphic.Rect</a></li>
                                <li><a href="../classes/nx.graphic.Stage.html">nx.graphic.Stage</a></li>
                                <li><a href="../classes/nx.graphic.Text.html">nx.graphic.Text</a></li>
                                <li><a href="../classes/nx.graphic.Topology.html">nx.graphic.Topology</a></li>
                                <li><a href="../classes/nx.graphic.Topology.AbstractLink.html">nx.graphic.Topology.AbstractLink</a></li>
                                <li><a href="../classes/nx.graphic.Topology.AbstractNode.html">nx.graphic.Topology.AbstractNode</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Categories.html">nx.graphic.Topology.Categories</a></li>
                                <li><a href="../classes/nx.graphic.Topology.CircleGroup.html">nx.graphic.Topology.CircleGroup</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Config.html">nx.graphic.Topology.Config</a></li>
                                <li><a href="../classes/nx.graphic.Topology.DefaultScene.html">nx.graphic.Topology.DefaultScene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Event.html">nx.graphic.Topology.Event</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Graph.html">nx.graphic.Topology.Graph</a></li>
                                <li><a href="../classes/nx.graphic.Topology.GroupItem.html">nx.graphic.Topology.GroupItem</a></li>
                                <li><a href="../classes/nx.graphic.Topology.GroupsLayer.html">nx.graphic.Topology.GroupsLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Layer.html">nx.graphic.Topology.Layer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LayoutMixin.html">nx.graphic.Topology.LayoutMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Link.html">nx.graphic.Topology.Link</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LinkMixin.html">nx.graphic.Topology.LinkMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LinkSet.html">nx.graphic.Topology.LinkSet</a></li>
                                <li><a href="../classes/nx.graphic.Topology.LinksLayer.html">nx.graphic.Topology.LinksLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NeXtForceLayout.html">nx.graphic.Topology.NeXtForceLayout</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Node.html">nx.graphic.Topology.Node</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NodeMixin.html">nx.graphic.Topology.NodeMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NodeSet.html">nx.graphic.Topology.NodeSet</a></li>
                                <li><a href="../classes/nx.graphic.Topology.NodesLayer.html">nx.graphic.Topology.NodesLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Path.html">nx.graphic.Topology.Path</a></li>
                                <li><a href="../classes/nx.graphic.Topology.PathLayer.html">nx.graphic.Topology.PathLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.PolygonGroup.html">nx.graphic.Topology.PolygonGroup</a></li>
                                <li><a href="../classes/nx.graphic.Topology.RectGroup.html">nx.graphic.Topology.RectGroup</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Scene.html">nx.graphic.Topology.Scene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.SceneMixin.html">nx.graphic.Topology.SceneMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.SelectionNodeScene.html">nx.graphic.Topology.SelectionNodeScene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.SelectionScene.html">nx.graphic.Topology.SelectionScene</a></li>
                                <li><a href="../classes/nx.graphic.Topology.StageMixin.html">nx.graphic.Topology.StageMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.ThreeDLayer.html">nx.graphic.Topology.ThreeDLayer</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Thumbnail.html">nx.graphic.Topology.Thumbnail</a></li>
                                <li><a href="../classes/nx.graphic.Topology.Tooltip.html">nx.graphic.Topology.Tooltip</a></li>
                                <li><a href="../classes/nx.graphic.Topology.TooltipManager.html">nx.graphic.Topology.TooltipManager</a></li>
                                <li><a href="../classes/nx.graphic.Topology.TooltipMixin.html">nx.graphic.Topology.TooltipMixin</a></li>
                                <li><a href="../classes/nx.graphic.Topology.TooltipPolicy.html">nx.graphic.Topology.TooltipPolicy</a></li>
                                <li><a href="../classes/nx.graphic.Topology.USMapLayout.html">nx.graphic.Topology.USMapLayout</a></li>
                                <li><a href="../classes/nx.graphic.Topology.WorldMapLayout.html">nx.graphic.Topology.WorldMapLayout</a></li>
                                <li><a href="../classes/nx.graphic.Topology.ZoomBySelection.html">nx.graphic.Topology.ZoomBySelection</a></li>
                                <li><a href="../classes/nx.graphic.Triangle.html">nx.graphic.Triangle</a></li>
                                <li><a href="../classes/nx.ui.Popover.html">nx.ui.Popover</a></li>
                                <li><a href="../classes/nx.ui.Popup.html">nx.ui.Popup</a></li>
                                <li><a href="../classes/nx.ui.PopupContainer.html">nx.ui.PopupContainer</a></li>
                                <li><a href="../classes/nx.widget.ZIndexManager.html">nx.widget.ZIndexManager</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/nx.data.html">nx.data</a></li>
                                <li><a href="../modules/nx.geometry.html">nx.geometry</a></li>
                                <li><a href="../modules/nx.graphic.html">nx.graphic</a></li>
                                <li><a href="../modules/nx.graphic.Topology.html">nx.graphic.Topology</a></li>
                                <li><a href="../modules/nx.graphic.Topology.Group.html">nx.graphic.Topology.Group</a></li>
                                <li><a href="../modules/nx.math.html">nx.math</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/topology/js/topology/path/Path.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function (nx, global) {

    var Vector = nx.geometry.Vector;
    var Line = nx.geometry.Line;
    var colorIndex = 0;
    var colorTable = [&#x27;#b2e47f&#x27;, &#x27;#e4e47f&#x27;, &#x27;#bec2f9&#x27;, &#x27;#b6def7&#x27;, &#x27;#89f0de&#x27;];
    /**
     * A topology path class
     Path&#x27;s background colors : [&#x27;#b2e47f&#x27;, &#x27;#e4e47f&#x27;, &#x27;#bec2f9&#x27;, &#x27;#b6def7&#x27;, &#x27;#89f0de&#x27;]
     * @class nx.graphic.Topology.Path
     * @extend nx.graphic.Component
     * @module nx.graphic.Topology
     */

    nx.define(&quot;nx.graphic.Topology.Path&quot;, nx.graphic.Component, {
        view: {
            type: &#x27;nx.graphic.Group&#x27;,
            content: {
                name: &#x27;path&#x27;,
                type: &#x27;nx.graphic.Path&#x27;
            }
        },
        properties: {
            /**
             * get/set links&#x27;s style ,default value is
             value: {
                    &#x27;stroke&#x27;: &#x27;#666&#x27;,
                    &#x27;stroke-width&#x27;: &#x27;1px&#x27;
                }

             * @property pathStyle
             */
            pathStyle: {
                value: {
                    &#x27;stroke&#x27;: &#x27;#666&#x27;,
                    &#x27;stroke-width&#x27;: &#x27;0px&#x27;
                }
            },
            /**
             * Get/set a path&#x27;s width
             * @property pathWidth
             */
            pathWidth: {
                value: &quot;auto&quot;
            },
            /**
             * Get/set a path&#x27;s offset
             * @property pathGutter
             */
            pathGutter: {
                value: 13
            },
            /**
             * Get/set a path&#x27;s padding to a node
             * @property pathPadding
             */
            pathPadding: {
                value: &quot;auto&quot;
            },
            /**
             * Get/set path arrow type , &#x27;none&#x27;/&#x27;cap&#x27;/&#x27;full&#x27;/&#x27;end&#x27;
             * @property
             */
            arrow: {
                value: &#x27;none&#x27;
            },
            /**
             * Get/set links to draw a path pver it
             * @property links
             */
            links: {
                value: [],
                set: function (value) {
                    this._links = value;
                    this.edgeIdCollection().clear();
                    var edges = [];
                    if (nx.is(value, &quot;Array&quot;) || nx.is(value, nx.data.Collection)) {
                        nx.each(value, function (item) {
                            edges.push(item.model().id());
                        }.bind(this));
                        this.edgeIdCollection().addRange(edges);
                    }
                    this.draw();
                }
            },
            edgeIdCollection: {
                value: function () {
                    var allEdges, collection = new nx.data.ObservableCollection();
                    var watcher = function (pname, pvalue) {
                        this.draw();
                    }.bind(this);
                    collection.on(&quot;change&quot;, function (sender, evt) {
                        var waitForTopology = function (pname, pvalue) {
                            if (!pvalue) {
                                return;
                            }
                            this.unwatch(&quot;topology&quot;, waitForTopology);
                            allEdges = allEdges || nx.path(this, &quot;topology.graph.edges&quot;);
                            verticesIdCollection = this.verticesIdCollection();
                            var diff = [];
                            if (evt.action === &quot;add&quot;) {
                                nx.each(evt.items, function (item) {
                                    var edge = allEdges.getItem(item);
                                    edge.watch(&quot;generated&quot;, watcher);
                                    diff.push(edge.sourceID());
                                    diff.push(edge.targetID());
                                }.bind(this));
                                // update vertices
                                nx.each(diff, function (id) {
                                    if (!verticesIdCollection.contains(id)) {
                                        verticesIdCollection.add(id);
                                    }
                                });
                            } else {
                                nx.each(evt.items, function (item) {
                                    var edge = allEdges.getItem(item);
                                    edge.unwatch(&quot;generated&quot;, watcher);
                                }.bind(this));
                                // update vertices
                                // TODO improve this algorithm
                                verticesIdCollection.clear();
                                nx.each(collection, function (id) {
                                    var edge = allEdges.getItem(id);
                                    if (verticesIdCollection.contains(edge.sourceID())) {
                                        verticesIdCollection.add(edge.sourceID());
                                    }
                                    if (verticesIdCollection.contains(edge.targetID())) {
                                        verticesIdCollection.add(edge.targetID());
                                    }
                                }.bind(this));
                            }
                        }.bind(this);
                        if (!this.topology()) {
                            this.watch(&quot;topology&quot;, waitForTopology);
                        } else {
                            waitForTopology(&quot;topology&quot;, this.topology());
                        }
                    }.bind(this));
                    return collection;
                }
            },
            verticesIdCollection: {
                value: function () {
                    var allVertices, collection = new nx.data.ObservableCollection();
                    var watcher = function (pname, pvalue) {
                        this.draw();
                    }.bind(this);
                    collection.on(&quot;change&quot;, function (sender, evt) {
                        allVertices = allVertices || nx.path(this, &quot;topology.graph.vertices&quot;);
                        if (evt.action === &quot;add&quot;) {
                            nx.each(evt.items, function (item) {
                                var vertex = allVertices.getItem(item);
                                vertex.watch(&quot;position&quot;, watcher);
                            }.bind(this));
                        } else {
                            nx.each(evt.items, function (item) {
                                var vertex = allVertices.getItem(item);
                                vertex.unwatch(&quot;position&quot;, watcher);
                            }.bind(this));
                        }
                    }.bind(this));
                    return collection;
                }
            },
            /**
             * Reverse path direction
             * @property reverse
             */
            reverse: {
                value: false
            },
            owner: {

            },
            topology: {}
        },
        methods: {
            init: function (props) {
                this.inherited(props);
                var pathStyle = this.pathStyle();
                this.view(&quot;path&quot;).sets(pathStyle);

                if (!pathStyle.fill) {
                    this.view(&quot;path&quot;).setStyle(&quot;fill&quot;, colorTable[colorIndex++ % 5]);
                }

            },
            /**
             * Draw a path,internal
             * @method draw
             */
            draw: function () {
                if (!this.topology()) {
                    return;
                }
                var generated = true,
                    topo = this.topology(),
                    allEdges = nx.path(this, &quot;topology.graph.edges&quot;),
                    allVertices = nx.path(this, &quot;topology.graph.vertices&quot;);
                nx.each(this.verticesIdCollection(), function (id) {
                    var item = allVertices.getItem(id);
                    if (!item.generated()) {
                        generated = false;
                        return false;
                    }
                }.bind(this));
                nx.each(this.edgeIdCollection(), function (id) {
                    var item = allEdges.getItem(id);
                    if (!item.generated()) {
                        generated = false;
                        return false;
                    }
                }.bind(this));
                if (!generated) {
                    this.view(&quot;path&quot;).set(&#x27;d&#x27;, &quot;M0 0&quot;);
                    return;
                }

                var link, line1, line2, pt, d1 = [],
                    d2 = [];
                var stageScale = this.topology().stageScale();
                var pathWidth = this.pathWidth();
                var pathPadding = this.pathPadding();
                var paddingStart, paddingEnd;
                var arrow = this.arrow();
                var v1, v2;


                var edgeIds = this.edgeIdCollection();
                var links = [];
                nx.each(edgeIds, function (id) {
                    links.push(topo.getLink(id));
                });
                var linksSequentialArray = this._serializeLinks(links);
                var count = links.length;

                //first
                var firstLink = links[0];

                var offset = firstLink.getOffset();
                if (firstLink.reverse()) {
                    offset *= -1;
                }

                offset = new Vector(0, this.reverse() ? offset * -1 : offset);

                line1 = linksSequentialArray[0].translate(offset);


                if (pathPadding === &quot;auto&quot;) {
                    paddingStart = Math.min(firstLink.sourceNode().showIcon() ? 24 : 4, line1.length() / 4 / stageScale);
                    paddingEnd = Math.min(firstLink.targetNode().showIcon() ? 24 : 4, line1.length() / 4 / stageScale);
                } else if (nx.is(pathPadding, &#x27;Array&#x27;)) {
                    paddingStart = pathPadding[0];
                    paddingEnd = pathPadding[1];
                } else {
                    paddingStart = paddingEnd = pathPadding;
                }
                if (typeof paddingStart == &#x27;string&#x27; &amp;&amp; paddingStart.indexOf(&#x27;%&#x27;) &gt; 0) {
                    paddingStart = line1.length() * stageScale * parseInt(paddingStart, 10) / 100 / stageScale;
                }

                if (pathWidth === &quot;auto&quot;) {
                    pathWidth = Math.min(10, Math.max(3, Math.round(3 / stageScale))); //3/stageScale
                }
                pathWidth *= 1.5 * stageScale;
                v1 = new Vector(0, pathWidth / 2);
                v2 = new Vector(0, -pathWidth / 2);

                paddingStart *= stageScale;

                pt = line1.translate(v1).pad(paddingStart, 0).start;
                d1.push(&#x27;M&#x27;, pt.x, pt.y);
                pt = line1.translate(v2).pad(paddingStart, 0).start;
                d2.unshift(&#x27;L&#x27;, pt.x, pt.y, &#x27;Z&#x27;);

                if (links.length &gt; 1) {
                    for (var i = 1; i &lt; count; i++) {
                        link = links[i];
                        line2 = linksSequentialArray[i].translate(new Vector(0, link.getOffset()));
                        pt = line1.translate(v1).intersection(line2.translate(v1));

                        if (isFinite(pt.x) &amp;&amp; isFinite(pt.y)) {
                            d1.push(&#x27;L&#x27;, pt.x, pt.y);
                        }
                        pt = line1.translate(v2).intersection(line2.translate(v2));
                        if (isFinite(pt.x) &amp;&amp; isFinite(pt.y)) {
                            d2.unshift(&#x27;L&#x27;, pt.x, pt.y);
                        }
                        line1 = line2;
                    }
                } else {
                    line2 = line1;
                }

                if (typeof paddingEnd == &#x27;string&#x27; &amp;&amp; paddingEnd.indexOf(&#x27;%&#x27;) &gt; 0) {
                    paddingEnd = line2.length() * parseInt(paddingEnd, 10) / 100 / stageScale;
                }

                paddingEnd *= stageScale;

                if (arrow == &#x27;cap&#x27;) {
                    pt = line2.translate(v1).pad(0, 2.5 * pathWidth + paddingEnd).end;
                    d1.push(&#x27;L&#x27;, pt.x, pt.y);
                    pt = pt.add(line2.normal().multiply(pathWidth / 2));
                    d1.push(&#x27;L&#x27;, pt.x, pt.y);

                    pt = line2.translate(v2).pad(0, 2.5 * pathWidth + paddingEnd).end;
                    d2.unshift(&#x27;L&#x27;, pt.x, pt.y);
                    pt = pt.add(line2.normal().multiply(-pathWidth / 2));
                    d2.unshift(&#x27;L&#x27;, pt.x, pt.y);

                    pt = line2.pad(0, paddingEnd).end;
                    d1.push(&#x27;L&#x27;, pt.x, pt.y);
                } else if (arrow == &#x27;end&#x27;) {
                    pt = line2.translate(v1).pad(0, 2 * pathWidth + paddingEnd).end;
                    d1.push(&#x27;L&#x27;, pt.x, pt.y);

                    pt = line2.translate(v2).pad(0, 2 * pathWidth + paddingEnd).end;
                    d2.unshift(&#x27;L&#x27;, pt.x, pt.y);

                    pt = line2.pad(0, paddingEnd).end;
                    d1.push(&#x27;L&#x27;, pt.x, pt.y);
                } else if (arrow == &#x27;full&#x27;) {
                    pt = line2.pad(0, paddingEnd).end;
                    d1.push(&#x27;L&#x27;, pt.x, pt.y);
                } else {
                    pt = line2.translate(v1).pad(0, paddingEnd).end;
                    d1.push(&#x27;L&#x27;, pt.x, pt.y);
                    pt = line2.translate(v2).pad(0, paddingEnd).end;
                    d2.unshift(&#x27;L&#x27;, pt.x, pt.y);
                }

                this.view(&quot;path&quot;).set(&#x27;d&#x27;, d1.concat(d2).join(&#x27; &#x27;));
                //this.view(&quot;path&quot;).setTransform(null, null, this.topology().stageScale());

                //todo
                //                if (links.length == 1) {
                //                    firstLink.view().watch(&quot;opacity&quot;, function (prop, value) {
                //                        if (this.$ &amp;&amp; this.view(&quot;path&quot;) &amp;&amp; this.view(&quot;path&quot;).opacity) {
                //                            this.view(&quot;path&quot;).opacity(value);
                //                        }
                //                    }, this);
                //                }
            },

            _serializeLinks: function (links) {
                var linksSequentialArray = [];
                var len = links.length;

                if (this.reverse()) {
                    linksSequentialArray.push(new Line(links[0].targetVector(), links[0].sourceVector()));
                } else {
                    linksSequentialArray.push(new Line(links[0].sourceVector(), links[0].targetVector()));
                }

                for (var i = 1; i &lt; len; i++) {
                    var firstLink = links[i - 1];
                    var secondLink = links[i];
                    var firstLinkSourceVector = firstLink.sourceVector();
                    var firstLinkTargetVector = firstLink.targetVector();
                    var secondLinkSourceVector = secondLink.sourceVector();
                    var secondLinkTargetVector = secondLink.targetVector();

                    if (firstLink.targetNodeID() == secondLink.sourceNodeID()) {
                        linksSequentialArray.push(new Line(secondLinkSourceVector, secondLinkTargetVector));
                    } else if (firstLink.targetNodeID() == secondLink.targetNodeID()) {
                        linksSequentialArray.push(new Line(secondLinkTargetVector, secondLinkSourceVector));
                    } else if (firstLink.sourceNodeID() == secondLink.sourceNodeID()) {
                        linksSequentialArray.pop();
                        linksSequentialArray.push(new Line(firstLinkTargetVector, firstLinkSourceVector));
                        linksSequentialArray.push(new Line(secondLinkSourceVector, secondLinkTargetVector));
                    } else {
                        linksSequentialArray.pop();
                        linksSequentialArray.push(new Line(firstLinkTargetVector, firstLinkSourceVector));
                        linksSequentialArray.push(new Line(secondLinkTargetVector, secondLinkSourceVector));
                    }
                }

                if (this.reverse()) {
                    linksSequentialArray.reverse();
                }

                return linksSequentialArray;
            },
            isEqual: function (pos1, pos2) {
                return pos1.x == pos2.x &amp;&amp; pos1.y == pos2.y;
            },
            dispose: function () {
                this.edgeIdCollection().clear();
                nx.each(this.nodes, function (node) {
                    node.off(&#x27;updateNodeCoordinate&#x27;, this.draw, this);
                }, this);
                this.inherited();
            }
        }
    });
})(nx, nx.global);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
