<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/base/data/ObservableCollection.js - Next graph</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Next graph" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/nx.html">nx</a></li>
                                <li><a href="../classes/nx.Comparable.html">nx.Comparable</a></li>
                                <li><a href="../classes/nx.data.Collection.html">nx.data.Collection</a></li>
                                <li><a href="../classes/nx.data.Counter.html">nx.data.Counter</a></li>
                                <li><a href="../classes/nx.data.Dictionary.html">nx.data.Dictionary</a></li>
                                <li><a href="../classes/nx.data.ObservableCollection.html">nx.data.ObservableCollection</a></li>
                                <li><a href="../classes/nx.data.ObservableDictionary.html">nx.data.ObservableDictionary</a></li>
                                <li><a href="../classes/nx.data.ObservableObject.html">nx.data.ObservableObject</a></li>
                                <li><a href="../classes/nx.data.Query.html">nx.data.Query</a></li>
                                <li><a href="../classes/nx.data.SortedMap.html">nx.data.SortedMap</a></li>
                                <li><a href="../classes/nx.Iterable.html">nx.Iterable</a></li>
                                <li><a href="../classes/nx.Object.html">nx.Object</a></li>
                                <li><a href="../classes/nx.Observable.html">nx.Observable</a></li>
                                <li><a href="../classes/nx.Serializable.html">nx.Serializable</a></li>
                                <li><a href="../classes/nxex.toolkit.collection.CollectionRelation.html">nxex.toolkit.collection.CollectionRelation</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/nx.html">nx</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/base/data/ObservableCollection.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function (nx) {

    var REGEXP_CHECK = /^(&amp;&amp;|\|\||&amp;|\||\^|-|\(|\)|[a-zA-Z\_][a-zA-Z\d\_]*|\s)*$/;
    var REGEXP_TOKENS = /&amp;&amp;|\|\||&amp;|\||\^|-|\(|\)|[a-zA-Z\_][a-zA-Z\d\_]*/g;
    var REGEXP_OPN = /[a-zA-Z\_][a-zA-Z\d\_]*/;
    var REGEXP_OPR = /&amp;&amp;|\|\||&amp;|\||\^|-|\(|\)/;
    var OPERATORNAMES = {
        &quot;-&quot;: &quot;complement&quot;,
        &quot;&amp;&quot;: &quot;cross&quot;,
        &quot;^&quot;: &quot;delta&quot;,
        &quot;|&quot;: &quot;union&quot;,
        &quot;&amp;&amp;&quot;: &quot;and&quot;,
        &quot;||&quot;: &quot;or&quot;
    };

    /**
     * @class ObservableCollection
     * @namespace nx.data
     * @extends nx.data.Collection
     * @uses nx.Observable
     */
    var EXPORT = nx.define(&#x27;nx.data.ObservableCollection&#x27;, nx.data.Collection, {
        mixins: nx.Observable,
        events: [&#x27;change&#x27;],
        methods: {
            /**
             * Add an item.
             * @method add
             * @param item
             */
            add: function (item) {
                item = this.inherited(item);
                if (!this._unique || item !== null) {
                    this.notify(&#x27;count&#x27;);
                    this.notify(&#x27;length&#x27;);
                    this.fire(&#x27;change&#x27;, {
                        action: &#x27;add&#x27;,
                        items: [item]
                    });
                }
                return item;
            },
            /**
             * @method addRange
             * @param iter
             */
            addRange: function (iter) {
                var items = this.inherited(iter);
                if (items.length) {
                    this.notify(&#x27;count&#x27;);
                    this.notify(&#x27;length&#x27;);
                    this.fire(&#x27;change&#x27;, {
                        action: &#x27;add&#x27;,
                        items: items
                    });
                }
                return items;
            },
            /**
             * @method insert
             * @param item
             * @param index
             */
            insert: function (item, index) {
                item = this.inherited(item, index);
                if (!this._unique || item !== null) {
                    this.notify(&#x27;count&#x27;);
                    this.notify(&#x27;length&#x27;);
                    this.fire(&#x27;change&#x27;, {
                        action: &#x27;add&#x27;,
                        items: [item],
                        index: index
                    });
                }
                return item;
            },
            /**
             * @method insertRange
             * @param iter
             * @param index
             */
            insertRange: function (iter, index) {
                var items = this.inherited(iter, index);
                if (items.length) {
                    this.notify(&#x27;count&#x27;);
                    this.notify(&#x27;length&#x27;);
                    this.fire(&#x27;change&#x27;, {
                        action: &#x27;add&#x27;,
                        items: items,
                        index: index
                    });
                }
                return items;
            },
            /**
             * @method remove
             * @param item
             */
            remove: function (item) {
                var result;
                if (arguments.length &gt; 1) {
                    item = Array.prototype.slice.call(arguments);
                    result = this.inherited.apply(this, item);
                    if (result.length) {
                        this.notify(&#x27;count&#x27;);
                        this.notify(&#x27;length&#x27;);
                        this.fire(&#x27;change&#x27;, {
                            action: &#x27;remove&#x27;,
                            items: item,
                            indices: result
                        });
                    }
                    return result;
                }
                result = this.inherited(item);
                if (result &gt;= 0) {
                    this.notify(&#x27;count&#x27;);
                    this.notify(&#x27;length&#x27;);
                    this.fire(&#x27;change&#x27;, {
                        action: &#x27;remove&#x27;,
                        items: [item],
                        index: result,
                        indices: [result]
                    });
                }
                return result;
            },
            /**
             * @method removeAt
             * @param index
             */
            removeAt: function (index) {
                var result = this.inherited(index);
                if (result !== undefined) {
                    this.notify(&#x27;count&#x27;);
                    this.notify(&#x27;length&#x27;);
                    this.fire(&#x27;change&#x27;, {
                        action: &#x27;remove&#x27;,
                        items: [result],
                        index: index
                    });
                }
                return result;
            },
            /**
             * @method clear
             */
            clear: function () {
                var result = this.inherited();
                this.notify(&#x27;count&#x27;);
                this.notify(&#x27;length&#x27;);
                this.fire(&#x27;change&#x27;, {
                    action: &#x27;clear&#x27;,
                    items: result
                });
            },
            /**
             * @method sort
             * @param comp
             */
            sort: function (comp) {
                var result = this.inherited(comp);
                this.notify(&#x27;count&#x27;);
                this.notify(&#x27;length&#x27;);
                this.fire(&#x27;change&#x27;, {
                    action: &#x27;sort&#x27;,
                    comparator: comp || function (a, b) {
                        if (a &gt; b) {
                            return 1;
                        } else if (a &lt; b) {
                            return -1;
                        } else {
                            return 0;
                        }
                    }
                });
                return result;
            },
            /**
             * Apply a diff watcher, which handles each item in the collection, to the collection.
             *
             * @method monitor
             * @param handler lambda(item) returning a rollback method
             * @return unwatcher A Object with unwatch method.
             */
            monitor: function (handler) {
                var collection = this;
                // resource (aka. rollback-methods) manager
                var resmgr = {
                    // retains item-vs-rollback-method pairs
                    objcache: [],
                    // since NEXT objects have identified ID, map is used more often
                    idcache: {},
                    // find pair index of indicated item in obj-cache
                    findPair: function (item) {
                        var i;
                        for (i = 0; i &lt; resmgr.objcache.length; i++) {
                            if (item === resmgr.objcache[i][0]) {
                                return i;
                            }
                        }
                        return -1;
                    },
                    // get the rollback method of given item
                    get: function (item) {
                        if (item.__id__) {
                            return resmgr.idcache[item.__id__];
                        } else {
                            var pair = resmgr.objcache[resmgr.findPair(item)];
                            return pair &amp;&amp; pair[1];
                        }
                    },
                    // set or remove(with null value) rollback method, will call the old rollback method if exists
                    set: function (item, res) {
                        if (item.__id__) {
                            if (resmgr.idcache[item.__id__]) {
                                resmgr.idcache[item.__id__].call(collection);
                            }
                            if (res) {
                                resmgr.idcache[item.__id__] = res;
                            } else {
                                delete resmgr.idcache[item.__id__];
                            }
                        } else {
                            var pairidx = resmgr.findPair(item);
                            var pair = resmgr.objcache[pairidx];
                            if (pair) {
                                if (pair[1] === res) {
                                    return;
                                }
                                pair[1].call(collection);
                                if (!res) {
                                    resmgr.objcache.splice(pairidx, 1);
                                } else {
                                    pair[1] = res;
                                }
                            } else if (res) {
                                pair = [item, res];
                                resmgr.objcache.push(pair);
                            }
                        }
                    },
                    // call all rollback methods
                    release: function () {
                        nx.each(resmgr.idcache, function (res, key) {
                            res();
                        });
                        nx.each(resmgr.objcache, function (pair) {
                            pair[1]();
                        });
                    }
                };
                // watch the further change of the collection
                var listener = collection.on(&quot;change&quot;, function (sender, evt) {
                    switch (evt.action) {
                    case &quot;add&quot;:
                        nx.each(evt.items, function (item) {
                            var res = handler(item);
                            if (res) {
                                resmgr.set(item, res);
                            }
                        });
                        break;
                    case &quot;remove&quot;:
                    case &quot;clear&quot;:
                        nx.each(evt.items, function (item) {
                            resmgr.set(item, null);
                        });
                        break;
                    }
                });
                // and don&#x27;t forget the existing items in the collection
                nx.each(collection, function (item) {
                    var res = handler(item);
                    if (res) {
                        resmgr.set(item, res);
                    }
                });
                // return unwatcher
                return {
                    release: function () {
                        resmgr.release();
                        listener.release();
                    }
                };
            },
            /**
             * Select a sub-collection from a source collection.
             * Usage:
             * &lt;pre&gt;
             * // select all items from collection with property active==true
             * resource = subCollection.select(collection, &quot;active&quot;)
             * // select all items from collection with path owner.name==&quot;Knly&quot;
             * resource = subCollection.select(collection, &quot;owner.name&quot;, function(name){
             *     return name===&quot;Knly&quot;;
             * });
             * // select all string item from collection
             * resource = subCollection.select(collection, function(item){
             *     return typeof item === &quot;string&quot;;
             * });
             * &lt;/pre&gt;
             * 
             * @method select
             * @param {nx.data.ObservableCollection} source
             * @param {String} conditions
             * @param {Function} determinator
             * @return resource for release the binding
             */
            select: function (source, conditions, determinator) {
                if (!nx.is(source, EXPORT)) {
                    return null;
                }
                if (typeof conditions === &quot;function&quot;) {
                    determinator = conditions;
                    conditions = null;
                }
                if (!determinator) {
                    determinator = nx.identity;
                }
                var self = this;
                this.clear();
                var resource = source.monitor(function (item) {
                    var resource;
                    if (conditions) {
                        if (nx.is(item, nx.Observable)) {
                            // monitor the specified conditions
                            resource = nx.Observable.monitor(item, conditions, function () {
                                self.toggle(item, determinator.apply(self, arguments));
                            });
                            resource.affect();
                        } else {
                            // determine the specified conditions if unable to monitor
                            self.toggle(item, determinator.call(self, nx.path(item, conditions)));
                        }
                    } else {
                        // no condition specified means determine item itself
                        self.toggle(item, determinator.call(self, item));
                    }
                    return function () {
                        resource &amp;&amp; resource.release();
                        self.toggle(item, false);
                    };
                });
                return resource;
            },
            /**
             * Calculate and synchronize collection with a collection calculation.
             *
             * @method calculate
             * @param experssion
             * @param sources
             * @return resource for release the binding
             */
            calculate: function (expression, sources) {
                var calculation = new EXPORT.Calculation(sources);
                return calculation.calculate(this, expression);
            }
        },
        statics: {
            /**
             * Prepare a calculation provider for a map of collections.
             *
             * @class CollectionRelation
             * @namespace nxex.toolkit.collection
             * @constructor
             * @param map {Object/Map} A map indicates names of the collection for calculation.
             */
            Calculation: nx.define({
                properties: {
                    map: {
                        value: function () {
                            return new nx.data.ObservableDictionary();
                        }
                    }
                },
                methods: {
                    init: function (map) {
                        this.map().setItems(map);
                    },
                    /**
                     * Apply a inter-collection releation to a collection.
                     * Supported operators:&lt;br/&gt;
                     * &lt;table&gt;
                     * &lt;tr&gt;&lt;th&gt;Operator&lt;/th&gt;&lt;th&gt;Calculation&lt;/th&gt;&lt;th&gt;Method&lt;/th&gt;&lt;/tr&gt;
                     * &lt;tr&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;&lt;td&gt;Sets cross&lt;/td&gt;&lt;td&gt;cross&lt;/td&gt;&lt;/tr&gt;
                     * &lt;tr&gt;&lt;td&gt;|&lt;/td&gt;&lt;td&gt;Sets union&lt;/td&gt;&lt;td&gt;union&lt;/td&gt;&lt;/tr&gt;
                     * &lt;tr&gt;&lt;td&gt;^&lt;/td&gt;&lt;td&gt;Sets symmetric difference&lt;/td&gt;&lt;td&gt;delta&lt;/td&gt;&lt;/tr&gt;
                     * &lt;tr&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Sets complement&lt;/td&gt;&lt;td&gt;complement&lt;/td&gt;&lt;/tr&gt;
                     * &lt;tr&gt;&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;&lt;td&gt;Sets logical and&lt;/td&gt;&lt;td&gt;and&lt;/td&gt;&lt;/tr&gt;
                     * &lt;tr&gt;&lt;td&gt;||&lt;/td&gt;&lt;td&gt;Sets logical or&lt;/td&gt;&lt;td&gt;or&lt;/td&gt;&lt;/tr&gt;
                     * &lt;/table&gt;
                     * Tips:
                     * &lt;ul&gt;
                     * &lt;li&gt;Logical and means &#x27;first empty collection or last collection&#x27;&lt;/li&gt;
                     * &lt;li&gt;Logical or means &#x27;first non-empty collection or last collection&#x27;&lt;/li&gt;
                     * &lt;/ul&gt;
                     *
                     * @method calculate
                     * @param target {Collection} The target collection.
                     * @param expression {String} The relation expression.
                     * @return An object with release method.
                     */
                    calculate: function (target, expression) {
                        // TODO more validation on the expression
                        if (!expression.match(REGEXP_CHECK)) {
                            throw new Error(&quot;Bad expression.&quot;);
                        }
                        var self = this;
                        var map = this.map();
                        var tokens = expression.match(REGEXP_TOKENS);
                        var requirements = tokens.filter(RegExp.prototype.test.bind(REGEXP_OPN));
                        var tree = EXPORT.buildExpressionTree(tokens);
                        // sync with the collection existence
                        var res, monitor;
                        var reqmgr = {
                            count: 0,
                            map: {},
                            sync: function () {
                                res &amp;&amp; (res.release(), res = null);
                                if (reqmgr.count === requirements.length) {
                                    target.clear();
                                    if (typeof tree === &quot;string&quot;) {
                                        // need not to calculate
                                        res = self.map().getItem(tree).monitor(EXPORT.getCollectionSyncMonitor(target));
                                    } else {
                                        res = self._calculate(target, tree);
                                    }
                                }
                            },
                            monitor: function (key, value) {
                                if (requirements.indexOf(key) &gt;= 0) {
                                    /*
                                    if (map[key] &amp;&amp; !value) {
                                        reqmgr.count--;
                                    } else if (!map[key] &amp;&amp; value) {
                                        reqmgr.count++;
                                    }*/
                                    reqmgr.count += ((!reqmgr.map[key]) * 1 + (!!value) * 1 - 1);
                                    reqmgr.map[key] = value;
                                    reqmgr.sync();
                                }
                            }
                        };
                        monitor = map.monitor(reqmgr.monitor);
                        return {
                            release: function () {
                                res &amp;&amp; res.release();
                                monitor.release();
                            }
                        };
                    },
                    _calculate: function (target, tree) {
                        var self = this;
                        var res, iterate, opr = tree[0];
                        // short-circuit for logical operatiors (&amp;&amp; and ||)
                        switch (opr) {
                        case &quot;&amp;&amp;&quot;:
                            iterate = function (idx) {
                                var coll, calc, watch, itr;
                                if (typeof tree[idx] === &quot;string&quot;) {
                                    coll = self.map().getItem(tree[idx]);
                                } else {
                                    coll = new nx.data.ObservableCollection();
                                    calc = self._calculate(coll, tree[idx]);
                                }
                                if (idx &gt;= tree.length - 1) {
                                    watch = coll.monitor(function (item) {
                                        target.add(item);
                                        return function () {
                                            target.remove(item);
                                        };
                                    });
                                } else {
                                    watch = coll.watch(&quot;length&quot;, function (n, v) {
                                        if (v) {
                                            itr = iterate(idx + 1);
                                        } else if (itr) {
                                            itr.release();
                                            itr = null;
                                        }
                                    });
                                    watch.affect();
                                }
                                return {
                                    release: function () {
                                        itr &amp;&amp; itr.release();
                                        watch &amp;&amp; watch.release();
                                        calc &amp;&amp; calc.release();
                                    }
                                };
                            };
                            res = iterate(1);
                            break;
                        case &quot;||&quot;:
                            iterate = function (idx) {
                                var coll, calc, watch, itr;
                                if (typeof tree[idx] === &quot;string&quot;) {
                                    coll = self.map().getItem(tree[idx]);
                                } else {
                                    coll = new nx.data.ObservableCollection();
                                    calc = self._calculate(coll, tree[idx]);
                                }
                                if (idx &gt;= tree.length - 1) {
                                    watch = coll.monitor(EXPORT.getCollectionSyncMonitor(target));
                                } else {
                                    watch = coll.watch(&quot;length&quot;, function (n, v) {
                                        if (itr) {
                                            itr.release();
                                        }
                                        if (!v) {
                                            itr = iterate(idx + 1);
                                        } else {
                                            itr = coll.monitor(EXPORT.getCollectionSyncMonitor(target));
                                        }
                                    });
                                    watch.affect();
                                }
                                return {
                                    release: function () {
                                        itr &amp;&amp; itr.release();
                                        watch &amp;&amp; watch.release();
                                        calc &amp;&amp; calc.release();
                                    }
                                };
                            };
                            res = iterate(1);
                            break;
                        default:
                            iterate = function () {
                                var i, coll, colls = [];
                                var calc, calcs = [];
                                for (i = 1; i &lt; tree.length; i++) {
                                    if (typeof tree[i] === &quot;string&quot;) {
                                        coll = self.map().getItem(tree[i]);
                                    } else {
                                        coll = new nx.data.ObservableCollection();
                                        calc = self._calculate(coll, tree[i]);
                                    }
                                    colls.push(coll);
                                    calcs.push(calc);
                                }
                                calc = EXPORT[OPERATORNAMES[opr]](target, colls);
                                return {
                                    release: function () {
                                        nx.each(calcs, function (calc) {
                                            calc &amp;&amp; calc.release();
                                        });
                                        calc.release();
                                    }
                                };
                            };
                            res = iterate();
                            break;
                        }
                        return res;
                    }
                }
            }),
            /**
             * This util returns a monitor function of ObservableCollection, which is used to synchronize item existance between 2 collections.
             *
             * @method getCollectionSyncMonitor
             * @param collection The target collection to be synchronized.
             * @param sync
             *  &lt;ul&gt;
             *  &lt;li&gt;If true, make sure target collection will have all items as source collection has;&lt;/li&gt;
             *  &lt;li&gt;If false, make sure target collection will not have any item as source collection has.&lt;/li&gt;
             *  &lt;/ul&gt;
             *  Default true.
             * @return {function&amp;lt;item&amp;gt;}
             *  The monitor function.
             */
            getCollectionSyncMonitor: function (coll, sync) {
                if (sync !== false) {
                    return function (item) {
                        coll.add(item);
                        return function () {
                            coll.remove(item);
                        };
                    };
                } else {
                    return function (item) {
                        coll.remove(item);
                        return function () {
                            coll.add(item);
                        };
                    };
                }
            },
            /**
             * Affect target to be the cross collection of sources collections.
             * Release object could stop the dependencies.
             *
             * @method cross
             * @param target {Collection}
             * @param sources {Array of Collection}
             * @return an object with release method
             * @static
             */
            cross: function (target, sources) {
                target.clear();
                var counter = new nx.data.Counter();
                var monitors = [];
                var increaseHandler = counter.on(&quot;increase&quot;, function (o, evt) {
                    if (evt.count == sources.length) {
                        target.add(evt.item);
                    }
                });
                var decreaseHandler = counter.on(&quot;decrease&quot;, function (o, evt) {
                    if (evt.count == sources.length - 1) {
                        target.remove(evt.item);
                    }
                });

                nx.each(sources, function (coll) {
                    var monitor = coll.monitor(function (item) {
                        counter.increase(item, 1);
                        return function () {
                            counter.decrease(item, 1);
                        };
                    });
                    monitors.push(monitor);
                });
                return {
                    release: function () {
                        increaseHandler.release();
                        decreaseHandler.release();
                        nx.each(monitors, function (monitor) {
                            monitor.release();
                        });
                    }
                };
            },
            /**
             * Affect target to be the union collection of sources collections.
             * Release object could stop the dependencies.
             *
             * @method union
             * @param target {Collection}
             * @param sources {Array of Collection}
             * @return an object with release method
             * @static
             */
            union: function (target, sources) {
                target.clear();
                var counter = new nx.data.Counter();
                var monitors = [];
                var increaseHandler = counter.on(&quot;increase&quot;, function (o, evt) {
                    if (evt.count === 1) {
                        target.add(evt.item);
                    }
                });
                var decreaseHandler = counter.on(&quot;decrease&quot;, function (o, evt) {
                    if (evt.count === 0) {
                        target.remove(evt.item);
                    }
                });

                nx.each(sources, function (coll) {
                    var monitor = coll.monitor(function (item) {
                        counter.increase(item, 1);
                        return function () {
                            counter.decrease(item, 1);
                        };
                    });
                    monitors.push(monitor);
                });
                return {
                    release: function () {
                        increaseHandler.release();
                        decreaseHandler.release();
                        nx.each(monitors, function (monitor) {
                            monitor.release();
                        });
                    }
                };
            },
            /**
             * Affect target to be the complement collection of sources collections.
             * Release object could stop the dependencies.
             *
             * @method complement
             * @param target {Collection}
             * @param sources {Array of Collection}
             * @return an object with release method
             * @static
             */
            complement: function (target, sources) {
                target.clear();
                var counter = new nx.data.Counter();
                var monitors = [];
                var length = sources.length;
                var changeHandler = counter.on(&quot;change&quot;, function (o, evt) {
                    var previous = evt.previousCount,
                        count = evt.count;
                    if (previous &lt; length &amp;&amp; count &gt;= length) {
                        target.add(evt.item);
                    }
                    if (previous &gt;= length &amp;&amp; count &lt; length) {
                        target.remove(evt.item);
                    }
                });
                var globalMonitor = sources[0].monitor(function (item) {
                    counter.increase(item, length);
                    return function () {
                        counter.decrease(item, length);
                    };
                });
                monitors.push(globalMonitor);
                nx.each(sources, function (coll, index) {
                    if (index &gt; 0) {
                        var monitor = coll.monitor(function (item) {
                            counter.decrease(item);
                            return function () {
                                counter.increase(item);
                            };
                        });
                        monitors.push(monitor);
                    }
                });
                return {
                    release: function () {
                        changeHandler.release();
                        nx.each(monitors, function (monitor) {
                            monitor.release();
                        });
                    }
                };
            },
            /**
             * Affect target to be the symmetric difference collection of sources collections.
             * Release object could stop the dependencies.
             * The name &#x27;delta&#x27; is the symbol of this calculation in mathematics.
             * @reference {http://en.wikipedia.org/wiki/Symmetric_difference}
             * @method delta
             * @param target {Collection}
             * @param sources {Array of Collection}
             * @return an object with release method
             * @static
             */
            delta: function (target, sources) {
                target.clear();
                var bound = true;
                var monitors = [];
                nx.each(sources, function (coll) {
                    var monitor = coll.monitor(function (item) {
                        target.toggle(item);
                        return function () {
                            if (bound) {
                                target.toggle(item);
                            }
                        };
                    });
                    monitors.push(monitor);
                });
                return {
                    release: function () {
                        bound = false;
                        nx.each(monitors, function (monitor) {
                            monitor.release();
                        });
                    }
                };
            },
            /**
             * Affect target to be the equivalent collection of the first non-empty collection.
             * Release object could stop the dependencies.
             *
             * @method or
             * @param target {Collection}
             * @param sources {Array of Collection}
             * @return an object with release method
             * @static
             */
            or: function (target, sources) {
                target.clear();
                var res, bound = true;
                var iterator = function (index) {
                    var watch, res, coll = sources[index];
                    watch = coll.watch(&#x27;length&#x27;, function (name, value) {
                        res &amp;&amp; res.release();
                        if (index &lt; sources.length - 1 &amp;&amp; !value) {
                            res = iterator(index + 1);
                        } else {
                            res = coll.monitor(function (item) {
                                target.add(item);
                                return function () {
                                    if (bound) {
                                        target.remove(item);
                                    }
                                };
                            });
                        }
                    });
                    watch.affect();
                    return {
                        release: function () {
                            res &amp;&amp; res.release();
                            watch &amp;&amp; watch.release();
                        }
                    };
                };
                res = iterator(0);
                return {
                    release: function () {
                        bound = false;
                        res.release();
                    }
                };
            },
            /**
             * Affect target to be the equivalent collection of the first empty collection or the last collection.
             * Release object could stop the dependencies.
             *
             * @method and
             * @param target {Collection}
             * @param sources {Array of Collection}
             * @return an object with release method
             * @static
             */
            and: function (target, sources) {
                target.clear();
                var bound = true;
                var iterate = function (idx) {
                    var watcher, resource, coll = sources[idx];
                    if (idx === sources.length - 1) {
                        return coll.monitor(function (item) {
                            target.add(item);
                            return function () {
                                if (bound) {
                                    target.remove(item);
                                }
                            };
                        });
                    }
                    watcher = coll.watch(&quot;length&quot;, function (n, v) {
                        if (v) {
                            resource = iterate(idx + 1);
                        } else if (resource) {
                            resource.release();
                            resource = null;
                        }
                    });
                    watcher.affect();
                    return {
                        release: function () {
                            if (resource) {
                                resource.release();
                            }
                            watcher.release();
                        }
                    };
                };
                var resource = iterate(0);
                return {
                    release: function () {
                        bound = false;
                        resource.release();
                    }
                };
            },
            /**
             * Build a tree of expresson syntax with the expression tokens.
             * e.g. tokens [&quot;A&quot;, &quot;|&quot;, &quot;B&quot;, &quot;&amp;&quot;, &quot;(&quot;, &quot;C&quot;, &quot;&amp;&quot;, &quot;D&quot;, &quot;)&quot;], which was separated from expression &quot;A | B &amp; (C | D)&quot;,
             * will be separated into [|, A, [&amp;, B, [|, C, D]]], because &#x27;&amp;&#x27; has higher priority than &#x27;|&#x27;,
             * and braced &quot;C | D&quot; has higher priority than &amp;. &lt;br/&gt;
             * &lt;br/&gt;
             * Similar to the priorities in JavaScript:&lt;br/&gt;
             * &lt;table&gt;
             * &lt;tr&gt;&lt;th&gt;operator&lt;/th&gt;&lt;th&gt;functionality&lt;/th&gt;&lt;/tr&gt;
             * &lt;tr&gt;&lt;td&gt;()&lt;/td&gt;&lt;td&gt;braces&lt;/td&gt;&lt;/tr&gt;
             * &lt;tr&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;complement&lt;/td&gt;&lt;/tr&gt;
             * &lt;tr&gt;&lt;td&gt;&amp;&lt;/td&gt;&lt;td&gt;cross&lt;/td&gt;&lt;/tr&gt;
             * &lt;tr&gt;&lt;td&gt;^&lt;/td&gt;&lt;td&gt;symmetric difference&lt;/td&gt;&lt;/tr&gt;
             * &lt;tr&gt;&lt;td&gt;|&lt;/td&gt;&lt;td&gt;union&lt;/td&gt;&lt;/tr&gt;
             * &lt;tr&gt;&lt;td&gt;&amp;&amp;&lt;/td&gt;&lt;td&gt;and (the first empty collection or the last collection)&lt;/td&gt;&lt;/tr&gt;
             * &lt;tr&gt;&lt;td&gt;||&lt;/td&gt;&lt;td&gt;or (the first non-empty collection)&lt;/td&gt;&lt;/tr&gt;
             * &lt;/table&gt;
             *
             * @method buildExpressionTree
             * @param {Array of token} tokens
             * @return {Array tree} Parsed syntax tree of the expression tokens.
             * @static
             */
            buildExpressionTree: (function () {
                var PRIORITIES = [
                    [&quot;-&quot;],
                    [&quot;&amp;&quot;],
                    [&quot;^&quot;],
                    [&quot;|&quot;],
                    [&quot;&amp;&amp;&quot;],
                    [&quot;||&quot;]
                ];
                var getPriority = function (opr) {
                    for (var i = 0; i &lt; PRIORITIES.length; i++) {
                        if (PRIORITIES[i].indexOf(opr) &gt;= 0) {
                            return i;
                        }
                    }
                };
                var buildExpressionNode = function (opr, opn1, opn2) {
                    if (Object.prototype.toString.call(opn1) === &quot;[object Array]&quot; &amp;&amp; opn1[0] === opr) {
                        opn1.push(opn2);
                        return opn1;
                    }
                    return [opr, opn1, opn2];
                };
                return function (tokens) {
                    if (typeof tokens === &quot;string&quot;) {
                        tokens = tokens.match(REGEXP_TOKENS);
                    }
                    tokens = tokens.concat([&quot;)&quot;]);
                    var token, opr, oprstack = [];
                    var opn, opnstack = [];
                    var operands = [];
                    while (tokens.length) {
                        token = tokens.shift();
                        if (token === &quot;)&quot;) {
                            while ((opr = oprstack.pop())) {
                                if (opr === &quot;(&quot;) {
                                    break;
                                }
                                opn = opnstack.pop();
                                opnstack.push(buildExpressionNode(opr, opnstack.pop(), opn));
                            }
                        } else if (token === &quot;(&quot;) {
                            oprstack.push(token);
                        } else if (token.match(REGEXP_OPN)) {
                            opnstack.push(token);
                            if (operands.indexOf(token) == -1) {
                                operands.push(token);
                            }
                        } else if (token.match(REGEXP_OPR)) {
                            while (oprstack.length) {
                                opr = oprstack.pop();
                                if (opr === &quot;(&quot; || getPriority(opr) &gt; getPriority(token)) {
                                    oprstack.push(opr);
                                    break;
                                }
                                opn = opnstack.pop();
                                opnstack.push(buildExpressionNode(opr, opnstack.pop(), opn));
                            }
                            oprstack.push(token);
                        }
                    }
                    if (opnstack[0]) {
                        opnstack[0].operands = operands;
                    }
                    return opnstack[0];
                };
            })()
        }
    });
})(nx);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
